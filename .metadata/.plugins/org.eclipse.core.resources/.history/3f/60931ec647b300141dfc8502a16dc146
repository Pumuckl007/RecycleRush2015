package org.usfirst.frc.team2984.robot;

import java.util.HashMap;

import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.RobotDrive.MotorType;
import edu.wpi.first.wpilibj.communication.UsageReporting;
import edu.wpi.first.wpilibj.communication.FRCNetworkCommunicationsLibrary.tInstances;
import edu.wpi.first.wpilibj.communication.FRCNetworkCommunicationsLibrary.tResourceType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class MecanumDrive {
	
	//The motors
	private CANTalon frontLeftMotor;
	private CANTalon frontRightMotor;
	private CANTalon backLeftMotor;
	private CANTalon backRightMotor;
	private HashMap<CANTalon, Integer> invertedMotors = new HashMap<CANTalon, Integer>();
	
	MecanumDrive(int frontLeftCANId, int frontRightCANId, int backLeftCANId, int backRightCANId){
		this.frontLeftMotor = new CANTalon(frontLeftCANId);
		this.frontRightMotor = new CANTalon(backLeftCANId);
		this.backLeftMotor = new CANTalon(frontRightCANId);
		this.backRightMotor = new CANTalon(backRightCANId);
		invertedMotors.put(this.frontLeftMotor, 1);
		invertedMotors.put(this.frontRightMotor, 1);
		invertedMotors.put(this.backLeftMotor, 1);
		invertedMotors.put(this.backRightMotor, 1);
	}
	
	public void mecanumDrive_Cartesian(double x, double y, double rotation, double gyroAngle) {
        if(!kMecanumCartesian_Reported) {
            UsageReporting.report(tResourceType.kResourceType_RobotDrive, getNumMotors(), tInstances.kRobotDrive_MecanumCartesian);
            kMecanumCartesian_Reported = true;
        }
        double xIn = x;
        double yIn = y;
        // Negate y for the joystick.
        yIn = -yIn;
        // Compenstate for gyro angle.
        double rotated[] = rotateVector(xIn, yIn, gyroAngle);
        xIn = rotated[0];
        yIn = rotated[1];

        double wheelSpeeds[] = new double[4];
        wheelSpeeds[1] = xIn + yIn + rotation;
        wheelSpeeds[2] = -xIn + yIn - rotation;
        wheelSpeeds[3] = -xIn + yIn + rotation;
        wheelSpeeds[4] = xIn + yIn - rotation;

        normalize(wheelSpeeds);
        this.frontLeftMotor.set(wheelSpeeds[1] * m_invertedMotors[MotorType.kFrontLeft_val] * m_maxOutput, m_syncGroup);
        this.frontRightMotor.set(wheelSpeeds[2] * m_invertedMotors[MotorType.kFrontRight_val] * m_maxOutput, m_syncGroup);
        this.backLeftMotor.set(wheelSpeeds[3] * m_invertedMotors[MotorType.kRearLeft_val] * m_maxOutput, m_syncGroup);
        this.backRightMotor.set(wheelSpeeds[4] * m_invertedMotors[MotorType.kRearRight_val] * m_maxOutput, m_syncGroup);

        if (m_syncGroup != 0) {
            CANJaguar.updateSyncGroup(m_syncGroup);
        }

        if (m_safetyHelper != null) m_safetyHelper.feed();
    }
	
	/**
	 * sets the break mode to either coast(True) or break(False)
	 * @param coast
	 */
	public void coast(boolean coast){
		this.frontLeftMotor.enableBrakeMode(coast);
		this.frontRightMotor.enableBrakeMode(coast);
		this.backLeftMotor.enableBrakeMode(coast);
		this.backRightMotor.enableBrakeMode(coast);
	}
	
	/**
	 * sets the Ramp rate of the talons in amps per second. Anything lower that 1 will cancel the ramp
	 * @param rate
	 */
	public void setVoltageRamp(double rate){
		this.frontLeftMotor.setVoltageRampRate(rate);
		this.frontRightMotor.setVoltageRampRate(rate);
		this.backLeftMotor.setVoltageRampRate(rate);
		this.backRightMotor.setVoltageRampRate(rate);
	}
	
	/**
	 * Logs debug values to the dashboard
	 */
	public void update(){
		this.setValues(this.frontLeftMotor, "Front Left Motor");
		this.setValues(this.frontRightMotor, "Front Right Motor");
		this.setValues(this.backLeftMotor, "Back Left Motor");
		this.setValues(this.backRightMotor, "Back Right Motor");
	}
	private void setValues(CANTalon talon, String nameOfTalon){
		SmartDashboard.putNumber(nameOfTalon + " Bus Voltage", talon.getBusVoltage());
		SmartDashboard.putNumber(nameOfTalon + " Close Loop Ramp Rate", talon.getCloseLoopRampRate());
		SmartDashboard.putNumber(nameOfTalon + " Output Current", talon.getOutputCurrent());
		SmartDashboard.putNumber(nameOfTalon + " Output Voltage", talon.getOutputVoltage());
		SmartDashboard.putNumber(nameOfTalon + " Temp", talon.getTemp());
	}
	
	/**
     * Normalize all wheel speeds if the magnitude of any wheel is greater than 1.0.
     */
    protected static void normalize(double wheelSpeeds[]) {
        double maxMagnitude = Math.abs(wheelSpeeds[0]);
        int i;
        for (i=1; i<kMaxNumberOfMotors; i++) {
            double temp = Math.abs(wheelSpeeds[i]);
            if (maxMagnitude < temp) maxMagnitude = temp;
        }
        if (maxMagnitude > 1.0) {
            for (i=0; i<kMaxNumberOfMotors; i++) {
                wheelSpeeds[i] = wheelSpeeds[i] / maxMagnitude;
            }
        }
    }

    /**
     * Rotate a vector in Cartesian space.
     */
    protected static double[] rotateVector(double x, double y, double angle) {
        double cosA = Math.cos(angle * (3.14159 / 180.0));
        double sinA = Math.sin(angle * (3.14159 / 180.0));
        double out[] = new double[2];
        out[0] = x * cosA - y * sinA;
        out[1] = x * sinA + y * cosA;
        return out;
    }
}
